# Week 4

- [1. Presentation of Float Number : 浮点数的表示](#1-presentation-of-float-number--浮点数的表示)
    - [1.1. Train of Thought : 思路](#11-train-of-thought--思路)
    - [1.2. Details : 细节](#12-details--细节)
- [2. Transfer Between Integer and Float : 整数和浮点数的转换](#2-transfer-between-integer-and-float--整数和浮点数的转换)
    - [2.1. Train of Thought : 思路](#21-train-of-thought--思路)
    - [2.2. Details : 细节](#22-details--细节)
- [3. Get Executable File By Steps and Disassemble : 逐步得到可执行文件并反汇编](#3-get-executable-file-by-steps-and-disassemble--逐步得到可执行文件并反汇编)
    - [3.1. Get Executable File By Steps ：逐步得到可执行文件](#31-get-executable-file-by-steps-逐步得到可执行文件)
    - [3.2. Disassemble Result : 反汇编结果](#32-disassemble-result--反汇编结果)
    - [3.3. Comparison Between Compiled File Generated by Different Steps : 不同步骤生成的编译文件的比较](#33-comparison-between-compiled-file-generated-by-different-steps--不同步骤生成的编译文件的比较)

## 1. Presentation of Float Number : 浮点数的表示

源文件：[FloatStructure.c](./FloatStructure.c)  

### 1.1. Train of Thought : 思路

1. 按照浮点数定义分成三部份  
    1. `s`
    2. `exp`
    3. `frac`
2. 通过binary fraction的定义  
    1. 首先判断`s`，完成后将数字转为正数  
    2. 计算`E`，再转为`e`的十进制表示 
    3. 通过`frac`的定义，去掉最高位的1后得到`frac`的十进制表示  
3. 通过bit shift以及bit operation将三部份合并  

### 1.2. Details : 细节

1. 总是对`non-negative number`进行操作  
    因为和`signed integer`不同  
    `float number`的设计为其绝对值会是绝对值会随除`sign bit`外的位的增大而单调递增  
    且具有正负的对称性，因此总是确保是正数再进行转换  
2. 存在不精确的情况  
    由于`float number`的设计，其`frac`部分的精度是有限的  
    因此当有效位数超过一定范围时，会出现不精确的情况  
    例如在转换20250309为`float`时:  

    ```bash
    20250309 : 
    int     : Binary representation: 0000 0001 0011 0100 1111 1110 1100 0101 
    float   : Binary representation: 0100 1011 1001 1010 0111 1111 0110 0010 
    double  : Binary representation: 0100 0001 0111 0011 0100 1111 1110 1100 0101 0000 0000 0000 0000 0000 0000 0000 
    f1 : 20250308.000000 | d1 : 20250309.000000
    ```

    我们可以发现，`float`表示的值并非完全等于`int`的值  
    原因在于`float`的`frac`部分bits为23，而20250309的二进制表示有24位  
    超过了`float`的精度范围，因此会出现不精确的情况  
    此外，我们也可以借`binary`的区别来进行分析`float`的舍入策略  
    可以看到  
    `float`的`frac`部分为`001 1010 0111 1111 0110 0010`  
    而原`int`中去掉最开头的`1`之后的部分为`0011 0100 1111 1110 1100 0101`  
    此处因为超过了`float`的`frac`部分的精度，因此去了舍入  
    最后一位`1`被舍去，因此`float`的值比`int`的值小1  
    符合`float`的类型`round to even`的舍入策略  

## 2. Transfer Between Integer and Float : 整数和浮点数的转换

源文件：[IntAndFloat.c](./IntAndFloat.c)

### 2.1. Train of Thought : 思路

通过指针转换加上引用的方式，强制将`float`的`binary`直接转换为`integer`类型来解释  
再实现二进制的输出，以及存储，之后再用来找到最大子串  

### 2.2. Details : 细节

1. 将`float`的`binary presentation`直接转换为`integer`以通过位计算实现提取  

    ```c
    *(long long *)&f
    ```

    取得`float`二进制表示开头Byte的地址  
    转换为`integer`的指针，再取值  
2. 将数的二进制表示存入到数组之后再寻找最大字串
    实际上，对于没有进度损失或溢出的情况  
    可以直接借助`float`的`fraction`部分`integer`的去掉最大位的`1`的`binary`  
    此时它们是绝对一致的  
    但是为了一般性，我们还是将`float`的`binary`表示存入数组再进行操作

    ```txt
    int : 114514 | fnum : 114514.000000 | dnum : 114514.000000
    int    : Binary representation: 0000 0000 0000 0001 1011 1111 0101 0010 
    negint : Binary representation: 1111 1111 1111 1110 0100 0000 1010 1110 
    float  : Binary representation: 0100 0111 1101 1111 1010 1001 0000 0000 
    double : Binary representation: 0100 0000 1111 1011 1111 0101 0010 0000 0000 0000 0000 0000 0000 0000 0000 0000 
    decimal : 114514
    int     : 00000000000000011011111101010010
    float   : 01000111110111111010100100000000
    double  : 0100000011111011111101010010000000000000000000000000000000000000
    substring between int and float
    Max Substring: 11011111101010010
    substring between int and double
    Max Substring: 11011111101010010
    ```

## 3. Get Executable File By Steps and Disassemble : 逐步得到可执行文件并反汇编

### 3.1. Get Executable File By Steps ：逐步得到可执行文件

源文件: [gccLearning.c](./GccAndObjdump/gccLearning.c)  
正向汇编文件: [gccLearning.s](./GccAndObjdump/gccLearning.s)  
目标文件: [gccLearning.o](./GccAndObjdump/gccLearning.o)  
可执行文件: [gccLearning](./GccAndObjdump/gccLearning)  


1. 生成正向汇编文件  

    ```bash
    gcc -S gccLearning.c -o gccLearning.s
    ```

2. 生成目标文件  

    ```bash
    gcc -c gccLearning.c -o gccLearning.o
    ```

3. 生成可执行文件  

    ```bash
    gcc gccLearning.o -o gccLearning
    ```

### 3.2. Disassemble Result : 反汇编结果

反向汇编结果: [gccLearningDisassemble.txt](./GccAndObjdump/gccLearningDisassemble.txt)  

反汇编可执行文件  

```bash
objdump -d gccLearning > gccLearningDisassemble.txt
```

### 3.3. Comparison Between Compiled File Generated by Different Steps : 不同步骤生成的编译文件的比较

1. 编译生成  

    ```asm
    ...
    main:
    .LFB0:
        .cfi_startproc
        pushq	%rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq	%rsp, %rbp
        .cfi_def_cfa_register 6
        subq	$32, %rsp
        movl	$10, -4(%rbp)
        movq	$20, -16(%rbp)
        movw	$123, -18(%rbp)
    ...
    ```

2. 反汇编生成  

    ```asm
    ...
    0000000000001000 <_init>:
        1000:	48 83 ec 08          	sub    $0x8,%rsp
        1004:	48 8b 05 c5 2f 00 00 	mov    0x2fc5(%rip),%rax        # 3fd0 <__gmon_start__@Base>
        100b:	48 85 c0             	test   %rax,%rax
        100e:	74 02                	je     1012 <_init+0x12>
        1010:	ff d0                	call   *%rax
        1012:	48 83 c4 08          	add    $0x8,%rsp
        1016:	c3                   	ret
    ...
        ```  

正向编译得到的汇编文件与反汇编得到的汇编文件比较  
主要在于反汇编得到的文件中包含了更多的信息  

1. 文件格式：  
    `gccLearning.s` 是汇编源代码文件，包含了汇编指令和一些伪指令（如 .section、.globl 等）  
    `gccLearningDisassemble.txt` 是反汇编后的目标文件，包含了机器码对应的汇编指令  
2. 指令格式：  
    `gccLearning.s` 中的指令是人类可读的汇编代码，带有注释和标签  
    `gccLearningDisassemble.txt` 中的指令是从机器码反汇编得到的，包含了内存地址和机器码  
3. 注释和标签：  
    `gccLearning.s` 中包含了注释和标签（如 .LC0、.LC1 等），这些标签用于标识数据和代码段  
    `gccLearningDisassemble.txt` 中的标签是反汇编工具生成的，通常是内存地址（如 0000000000001139 \<main\>）  
4. 数据段：  
    `gccLearning.s` 中的数据段（如 .rodata）包含了字符串和常量数据  
    `gccLearningDisassemble.txt` 中的数据段被反汇编工具解释为指令或数据  
5. 伪指令：  
    `gccLearning.s` 中包含了伪指令（如 .section、.globl、.type 等），用于定义段、全局符号和函数类型  
    `gccLearningDisassemble.txt` 中没有这些伪指令，因为它们在目标文件中已经被处理  
