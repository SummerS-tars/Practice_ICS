# IPC (进程间通信) 演示程序

## 概述

这个程序演示了几种传统的进程间通信(Inter-Process Communication, IPC)机制，是《计算机系统导论》课程中重要的概念。

## 编译和运行

### 使用Makefile编译

```bash
make          # 编译程序
make run      # 编译并运行程序
make clean    # 清理生成的文件
make help     # 查看所有可用选项
```

### 手动编译

```bash
gcc -Wall -Wextra -g -std=c99 -o IPC IPC.c
./IPC
```

## 演示的IPC机制

### 1. 管道 (Pipe)

- **原理**: 管道是一种半双工的通信方式，数据只能单向流动
- **特点**: 
  - 父子进程或兄弟进程之间通信
  - 基于文件描述符
  - 先进先出(FIFO)
- **演示内容**: 父进程向管道写入消息，子进程从管道读取消息

### 2. 信号 (Signal)

- **原理**: 信号是软件中断，用于通知进程某个事件已经发生
- **特点**:
    - 异步通信方式
    - 只能传递简单的通知，不能传递数据
    - 进程可以设置信号处理函数
- **演示内容**: 父进程发送SIGUSR1信号给子进程，子进程接收并处理信号

### 3. 共享内存概念

- **原理**: 多个进程可以访问同一块物理内存区域
- **特点**:
    - 最快的IPC方式
    - 需要同步机制防止竞争条件
    - 在fork()中，子进程会复制父进程的内存空间
- **演示内容**: 展示fork()后父子进程内存空间的独立性

### 4. 文件描述符继承

- **原理**: fork()创建的子进程会继承父进程的文件描述符
- **特点**:
    - 子进程可以使用父进程打开的文件/管道/套接字
    - 多个进程可以共享同一个管道进行通信
- **演示内容**: 两个子进程通过继承的管道进行通信

## 核心概念解释

### Process vs Thread

- **进程**: 拥有独立内存空间的执行单元
- **线程**: 共享进程内存空间的执行单元
- **IPC**: 进程间通信，因为进程内存空间独立，需要特殊机制进行通信

### 为什么需要IPC?

1. **内存隔离**: 进程有独立的地址空间，不能直接访问其他进程的内存
2. **协作需求**: 现代应用程序通常由多个进程协作完成任务
3. **安全性**: 进程隔离提供了安全性，但需要controlled communication

### 传统IPC vs 现代IPC

**传统IPC机制**:

- 管道 (pipe)
- 命名管道 (FIFO)
- 信号 (signal)
- System V IPC (消息队列、信号量、共享内存)

**现代IPC机制**:

- POSIX IPC
- 套接字 (socket)
- 内存映射文件 (mmap)
- D-Bus (Linux桌面环境)

## 程序设计要点

1. **错误处理**: 每个系统调用都检查返回值
2. **资源清理**: 及时关闭文件描述符，回收子进程
3. **信号安全**: 信号处理函数使用信号安全的函数
4. **同步机制**: 使用wait()等待子进程结束

## 扩展练习

1. 修改程序，让两个子进程通过管道进行双向通信
2. 添加命名管道(FIFO)的演示
3. 实现一个简单的生产者-消费者模型
4. 添加信号量的使用示例

## 相关CSAPP章节

- 第8章: 异常控制流 (信号处理)
- 第10章: 系统级I/O (管道、文件描述符)
- 第12章: 并发编程 (进程间通信与同步)

## 注意事项

- 程序中有一个编译警告关于`kill`函数的隐式声明，这是正常的
- 信号演示部分可能需要几秒钟才能完成
- 所有演示都是在Linux环境下进行的
