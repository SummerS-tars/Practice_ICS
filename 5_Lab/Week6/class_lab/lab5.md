# ICS Lab 5

## 1. conditional code的访问和利用

1. 在C中写嵌入汇编代码，用汇编指令读取condition code判断是否发生进位、溢出和等于0。  
2. 利用第二次lab实现的C语言的判别方法。生成汇编后，对比汇编代码，比较两种实现方式的优缺点。

### 1.1. 编译并生成汇编代码

使用下列命令编译并生成汇编代码：

```bash
# 编译嵌入式汇编版本并生成汇编代码
gcc -S asm_condition.c -o asm_condition.s

# 编译纯C语言版本并生成汇编代码
gcc -S c_condition.c -o c_condition.s
```

### 1.2. 结果记录

```txt
=== 编译嵌入式汇编版本 ===

=== 编译纯C语言版本 ===

=== 运行嵌入式汇编版本 ===
计算: 2147483647 + 10
结果: -2147483639
进位标志 (CF): 0
溢出标志 (OF): 1
零标志 (ZF): 2038301184

=== 运行纯C语言版本 ===
计算: 2147483647 + 10
结果: -2147483639
进位标志 (CF): 0
溢出标志 (OF): 1
零标志 (ZF): 0

=== 生成的汇编代码比较 ===
嵌入式汇编版本的指令数:
63
纯C语言版本的指令数:
73
```

### 1.3. 分析比较

对比两个汇编文件`asm_condition.s`和`c_condition.s`，分析两种实现方式的区别：

1. **直接访问条件码（嵌入式汇编）的优缺点**：
   - 优点：
     - 直接访问硬件状态，无需额外计算
     - 执行效率更高，尤其在低级系统编程中
     - 代码执行速度可能更快，因为无需额外的计算逻辑
   - 缺点：
     - 不具有可移植性，依赖于特定的处理器架构
     - 代码可读性较差，难以维护
     - 需要对汇编语言有一定了解

2. **C语言判别方法的优缺点**：
   - 优点：
     - 代码可读性好，易于理解和维护
     - 具有良好的可移植性，可以在不同架构上运行
     - 无需了解汇编语言细节
   - 缺点：
     - 可能需要额外的计算步骤
     - 在某些情况下执行效率可能较低
     - 生成的汇编代码可能更长，指令数更多

## 2. loop structure

要求：给一段非常简单的用不同循环结构实现的包含双重循环累加计算的代码

### 2.1. 示例代码

以下是使用三种不同循环结构实现的双重循环累加计算的代码：

```c
// for循环实现
int sum_for() {
    int sum = 0;
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            sum += i + j;
        }
    }
    return sum;
}

// while循环实现
int sum_while() {
    int sum = 0, i = 0;
    while (i < 10) {
        int j = 0;
        while (j < 10) {
            sum += i + j;
            j++;
        }
        i++;
    }
    return sum;
}

// do-while循环实现
int sum_do_while() {
    int sum = 0, i = 0;
    do {
        int j = 0;
        do {
            sum += i + j;
            j++;
        } while (j < 10);
        i++;
    } while (i < 10);
    return sum;
}
```

### 2.2. 编译和生成汇编代码

使用以下命令分别编译并生成汇编代码：

```bash
# 不加优化
gcc -S loop_structures.c -o loop_structures_no_opt.s

# 加上优化开关
gcc -O1 -S loop_structures.c -o loop_structures_O1.s
gcc -O2 -S loop_structures.c -o loop_structures_O2.s
gcc -O3 -S loop_structures.c -o loop_structures_O3.s
```

### 2.3. 分析思路

1. **不加优化的汇编代码比较**：
   - 对比`loop_structures_no_opt.s`中三种循环结构的汇编代码，观察指令数量和结构差异。
   - 分析哪种循环结构生成的汇编代码更简洁，是否存在冗余指令。

2. **加优化后的汇编代码比较**：
   - 对比`loop_structures_O1.s`、`loop_structures_O2.s`和`loop_structures_O3.s`中三种循环结构的汇编代码。
   - 分析优化等级对汇编代码的影响，例如是否减少了指令数量、是否进行了循环展开等优化。

3. **总结**：
   - 比较不同循环结构在不同优化等级下的性能差异。
   - 总结优化对代码执行效率和指令数量的影响。

### 2.4. 汇编代码分析

#### 不加优化的汇编代码 (`loop_structures_no_opt.s`)

1. **指令数量**：
   - `sum_for`、`sum_while`和`sum_do_while`的实现中，循环结构的逻辑基本一致，均包含初始化、条件判断、累加操作和循环变量更新。
   - 汇编代码中存在较多冗余指令，例如每次循环都需要重新加载和存储变量。

2. **特点**：
   - 每个函数的循环逻辑完全展开，未进行任何优化。
   - 指令数量较多，寄存器使用效率较低。

#### 优化等级-O1的汇编代码 (`loop_structures_O1.s`)

1. **指令数量**：
   - 优化后，`sum_for`、`sum_while`和`sum_do_while`的汇编代码显著减少。
   - 使用了寄存器进行循环变量的存储和更新，减少了内存访问。

2. **特点**：
   - 循环逻辑仍然保留，但通过寄存器优化减少了冗余指令。
   - 汇编代码更紧凑，执行效率有所提升。

#### 优化等级-O2的汇编代码 (`loop_structures_O2.s`)

1. **指令数量**：
   - 进一步优化后，循环逻辑被部分展开，减少了循环判断的次数。
   - 汇编代码中使用了更高效的指令组合。

2. **特点**：
   - 循环展开优化显著减少了循环体内的指令数量。
   - 汇编代码更加紧凑，执行效率进一步提升。

#### 优化等级-O3的汇编代码 (`loop_structures_O3.s`)

1. **指令数量**：
   - `sum_for`、`sum_while`和`sum_do_while`的实现完全优化为常量返回值。
   - 汇编代码中直接返回累加结果`900`，完全消除了循环逻辑。

2. **特点**：
   - 编译器通过常量折叠优化，直接计算出结果，消除了所有循环。
   - 汇编代码最为简洁，执行效率达到理论最优。

### 2.5. 总结

1. **优化效果**：
   - 随着优化等级的提高，汇编代码的指令数量逐渐减少，执行效率逐步提升。
   - -O3优化等级通过常量折叠直接消除了循环逻辑，生成的汇编代码最为高效。

2. **不同循环结构的影响**：
   - 在不加优化的情况下，三种循环结构的汇编代码几乎一致。
   - 在高优化等级下，编译器对不同循环结构的处理趋于一致，最终生成的汇编代码相同。

3. **实验结论**：
   - 编译器优化对代码性能的提升具有显著作用。
   - 在实际开发中，应尽量使用高优化等级的编译选项以获得更高的执行效率。

## 3. switch

根据提供的源码，生成汇编代码和二进制码  
并且反汇编目标文件，生成汇编观察汇编代码  
比较两者的差异  
分别对两个汇编程序：  

1. 找到跳转表，并解释跳转表中的值  
2. 建立C代码语句和汇编代码块之间的映射关系

### 3.1. 分析work3_2.disasm反汇编代码

通过分析work3_2.disasm反汇编代码，我们可以了解switch语句在汇编层面的实现。

#### 3.1.1. 跳转表分析

在反汇编代码中，我们没有看到传统的跳转表实现。work3_2.c中的switch语句是通过一系列连续的比较和条件跳转指令实现的，而非通过跳转表。这可能是因为switch中的case数量较少（只有2个case和1个default），编译器选择了直接比较而非跳转表实现。

相关代码段：

```asm
0000000000001149 <main>:
    1149:	55                   	push   %rbp
    114a:	48 89 e5             	mov    %rsp,%rbp
    114d:	48 83 ec 10          	sub    $0x10,%rsp
    1151:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)       # 设置option = 1
    1158:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)       # 比较option是否等于1
    115c:	74 08                	je     1166 <main+0x1d>      # 如果等于1，跳转到case 1
    115e:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)       # 比较option是否等于2
    1162:	74 24                	je     1188 <main+0x3f>      # 如果等于2，跳转到case 2
    1164:	eb 33                	jmp    1199 <main+0x50>      # 否则跳转到default
```

在这个实现中，编译器采用的是串行比较法（sequential comparison），而不是跳转表。每个case值都被逐一比较，根据比较结果跳转到相应的代码块。

#### 3.1.2. C代码与汇编代码映射关系

下面是C代码语句和汇编代码块之间的映射关系：

1. **初始化部分**:

    ```c
    int option = 1;
    ```

    对应汇编代码:

    ```asm
    1151:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)       # 设置option = 1
    ```

2. **switch语句比较部分**:

    ```c
    switch(option)
    ```

    对应汇编代码:

    ```asm
    1158:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)       # 比较option是否等于1
    115c:	74 08                	je     1166 <main+0x1d>      # 如果等于1，跳转到case 1
    115e:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)       # 比较option是否等于2
    1162:	74 24                	je     1188 <main+0x3f>      # 如果等于2，跳转到case 2
    1164:	eb 33                	jmp    1199 <main+0x50>      # 否则跳转到default
    ```

3. **case 1部分**:

    ```c
    case 1:
    {
        int x = 10;
        printf("Option 1, x = %d\n", x);
        break;
    }
    ```

    对应汇编代码:

    ```asm
    1166:	c7 45 f8 0a 00 00 00 	movl   $0xa,-0x8(%rbp)       # int x = 10
    116d:	8b 45 f8             	mov    -0x8(%rbp),%eax       # 将x的值加载到eax寄存器
    1170:	89 c6                	mov    %eax,%esi             # 将x的值作为printf的第二个参数
    1172:	48 8d 05 8b 0e 00 00 	lea    0xe8b(%rip),%rax      # 加载格式字符串地址
    1179:	48 89 c7             	mov    %rax,%rdi             # 将格式字符串作为printf的第一个参数
    117c:	b8 00 00 00 00       	mov    $0x0,%eax             # 设置eax为0（浮点参数数量）
    1181:	e8 ba fe ff ff       	call   1040 <printf@plt>     # 调用printf函数
    1186:	eb 20                	jmp    11a8 <main+0x5f>      # 跳转到函数结束部分(break效果)
    ```

4. **case 2部分**:

    ```c
    case 2:
    {
        printf("Option 2, no variable used\n");
        break;
    }
    ```

    对应汇编代码:

    ```asm
    1188:	48 8d 05 87 0e 00 00 	lea    0xe87(%rip),%rax      # 加载格式字符串地址
    118f:	48 89 c7             	mov    %rax,%rdi             # 将格式字符串作为参数
    1192:	e8 99 fe ff ff       	call   1030 <puts@plt>       # 调用puts函数
    1197:	eb 0f                	jmp    11a8 <main+0x5f>      # 跳转到函数结束部分(break效果)
    ```

5. **default部分**:

    ```c
    default:
        printf("Unknown option\n");
    ```

    对应汇编代码:

    ```asm
    1199:	48 8d 05 91 0e 00 00 	lea    0xe91(%rip),%rax      # 加载格式字符串地址
    11a0:	48 89 c7             	mov    %rax,%rdi             # 将格式字符串作为参数
    11a3:	e8 88 fe ff ff       	call   1030 <puts@plt>       # 调用puts函数
    ```

6. **函数结束部分**:

    ```c
    return 0;
    ```

    对应汇编代码:

    ```asm
    11a8:	b8 00 00 00 00       	mov    $0x0,%eax             # 返回值设为0
    11ad:	c9                   	leave                         # 恢复栈帧
    11ae:	c3                   	ret                           # 返回
    ```

### 3.2. 分析总结

1. **switch语句的实现方式**:
   - 对于case较少的情况，编译器采用了串行比较法（sequential comparison），使用`cmp`和条件跳转指令（如`je`）实现。
   - 这种方式适用于case数量较少的情况，执行效率相对较高。

2. **变量作用域处理**:
   - 每个case块中的局部变量（如case 1中的int x = 10）被分配在栈上的不同位置。
   - 编译器确保了每个case块的变量不会相互干扰。

3. **break语句的实现**:
   - break语句在汇编代码中表现为无条件跳转指令（`jmp`），直接跳转到switch语句结束后的代码位置。

4. **优化观察**:
   - 编译器优化了输出语句，对于单纯的字符串输出，使用了更高效的`puts`函数而非`printf`。
   - 对于需要格式化输出的情况（如case 1），仍然使用`printf`函数。

5. **效率考虑**:
   - 当case数量增加时，串行比较的效率会降低，这种情况下编译器可能会选择使用跳转表实现switch语句以提高效率。
   - 跳转表实现通常适用于case值连续或者case数量较多的情况。
