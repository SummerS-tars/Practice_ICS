# ICS Lab 6

## 内容

### 课堂练习

需要提交代码和文档，描述观察到的现象，给出合理的解释。

1. 数组的访问

    一个程序有main和char array_store(unsigned int index, char val)两个函数。  
    array_store函数实现下列功能：  
    1. 申明一个字符数组，长度为10；
    2. 读出index指向的元素的值，并作为返回值。
    3. 把val写入到index所指的元素。

    在main函数中，构造一个循环把字符数组“012345678901234567890123456789”用函数array_store逐个写入，并输出返回值。

    请输出观察到的现象，并给出合理的解释。

2. 结构体
    1. 函数中申明如下结构体:  

        ```c
        struct s1 {
            char name;
            short code;
            int   value;
        }

        struct s2 {
            short code;
            int   value;
            char  name;
        }

        struct s3 {
            int value;
            char name;
            short code;
        }
        ```

    2. 每一个结构体申明一个变量，并分别赋值{0,10,100}, {10,100,0}和{100,0,10}。
        1. 用sizeof来获取每个结构体变量的大小，并输出值。
        2. 打印每个结构体变量的地址，和每个成员的地址。
        3. 尝试解释观察到的输出。  

3. 函数和函数指针  
    1. 程序由main函数和int myfunc(unsigned int len)构成。  
        1. myfunc计算1到len的平方和
        2. 把计算结果返回
    2. 在主程序里，申明一个函数指针int (*pfun)(unsigned int)，
        1. pfun = myfunc;  
            分别用pfun(10)和(*pfun)(10)，并打印返回的结果。
        2. pfun = &myfunc;  
            分别用pfun(10)和(*pfun)(10)，并打印返回的结果
    3. 内容  
        1. 记录观察到的现象。
        2. 生成汇编代码，并观察两个call的代码。
        3. 解释观察到的现象。

## 实验结果与解释

### 1. 数组访问实验

当运行数组访问实验程序时，可以观察到以下现象：  

1. 运行端：Ubuntu

    ```txt
    输入字符串长度: 30
    索引    输入字符        返回ASCII码
    ------------------------------------
    0       0               0
    1       1               0
    2       2               0
    3       3               -104
    4       4               -7
    5       5               79
    6       6               57
    7       7               -3
    8       8               127
    9       9               0
    10      0               48
    Segmentation fault (core dumped)
    ```

2. 运行端：Windows  

    ```txt
    输入字符串长度: 30
    索引    输入字符        返回ASCII码
    ------------------------------------
    0       0               0
    1       1               0
    2       2               0
    3       3               1
    4       4               0
    5       5               0
    6       6               0
    7       7               0
    8       8               0
    9       9               0
    10      0               48
    ```

**解释**：  

数组访问实验的现象分析：

1. **索引在范围内的访问(0-9)**
   - 在两个平台上，索引0-2的返回值都是0，这是正常的，因为静态数组初始化为0
   - Ubuntu上索引3-9的返回值出现随机值（如-104、-7等），这是因为静态数组可能未被完全初始化为0，或内存中原有的垃圾值
   - Windows上索引3-9大部分返回0，这可能与不同编译器的初始化行为有关

2. **索引超出范围的访问(>=10)**
   - 当索引为10时，两个平台都返回ASCII码48，这对应字符'0'
   - 这说明索引为10时访问到了数组边界之外的内存，可能是之前写入的数据

3. **平台差异**
   - Ubuntu上继续访问越界地址导致段错误(Segmentation fault)，表明程序尝试访问了受保护的内存区域
   - Windows上没有立即崩溃，这与操作系统内存保护机制有关，Windows可能允许更宽松的内存访问

4. **内存布局解释**
   - 静态数组在内存中是连续分配的
   - 越界访问时，我们实际上是在读写数组后面的内存位置
   - 当我们写入索引10时，实际上修改了数组后面紧邻的内存
   - 后续读取同一位置时，返回了先前写入的值(48，即字符'0')

5. **安全隐患**
   - 这种越界访问演示了C语言不进行边界检查的危险性
   - 在实际应用中，这可能导致：
     - 数据损坏：意外修改其他变量的值
     - 程序崩溃：如Ubuntu上的段错误
     - 安全漏洞：缓冲区溢出可能被恶意利用

这个实验清楚地展示了为何在C语言编程中应该特别注意数组边界检查，以防止潜在的内存安全问题和难以调试的错误。

### 2. 结构体实验

运行结构体实验程序，观察到以下结果（具体地址值在不同机器上会有差异）：

1. Linux:  

    ```txt
    结构体s1大小：8字节
    结构体s2大小：12字节
    结构体s3大小：8字节

    结构体s1地址：0x7ffde665f3a8
    s1.name地址：0x7ffde665f3a8
    s1.code地址：0x7ffde665f3aa
    s1.value地址：0x7ffde665f3ac

    结构体s2地址：0x7ffde665f39c
    s2.code地址：0x7ffde665f39c
    s2.value地址：0x7ffde665f3a0
    s2.name地址：0x7ffde665f3a4

    结构体s3地址：0x7ffde665f394
    s3.value地址：0x7ffde665f394
    s3.name地址：0x7ffde665f398
    s3.code地址：0x7ffde665f39a
    ```

2. Windows:  

    ```txt
    结构体s1大小：8字节
    结构体s2大小：12字节
    结构体s3大小：8字节

    结构体s1地址：000000cc42dffcc8
    s1.name地址：000000cc42dffcc8
    s1.code地址：000000cc42dffcca
    s1.value地址：000000cc42dffccc

    结构体s2地址：000000cc42dffcbc
    s2.code地址：000000cc42dffcbc
    s2.value地址：000000cc42dffcc0
    s2.name地址：000000cc42dffcc4

    结构体s3地址：000000cc42dffcb4
    s3.value地址：000000cc42dffcb4
    s3.name地址：000000cc42dffcb8
    s3.code地址：000000cc42dffcba
    ```

**解释**：

1. **结构体大小差异**：  
   - s1大小为8字节，s3也是8字节，但s2大小为12字节
   - 这是由于**内存对齐**导致的

2. **内存对齐规则**：
   - 每个成员的地址必须是其自身大小的整数倍（或编译器指定的对齐值的整数倍）
   - 整个结构体的大小必须是最大成员大小的整数倍

3. **具体分析**：
   - s1: `char(1) + 填充(1) + short(2) + int(4)` = 8字节
   - s2: `short(2) + 填充(2) + int(4) + char(1) + 填充(3)` = 12字节
   - s3: `int(4) + char(1) + 填充(1) + short(2)` = 8字节

4. **成员地址间隔**：
   - s1中name和code之间有1字节填充
   - s2中value和name之间无需填充，但结构体末尾有3字节填充
   - s3中name和code之间有1字节填充

内存对齐是为了提高CPU访问效率，虽然会浪费一些空间，但能显著提升性能。这也说明了为什么结构体成员的排列顺序会影响结构体的总大小。

### 3. 函数指针实验

运行函数指针实验程序，观察到以下结果：

1. Linux:  

    ```txt
    pfun(10) = 385
    (*pfun)(10) = 385
    pfun(10) = 385
    (*pfun)(10) = 385
    ```

2. Windows：  

    ```txt
    pfun(10) = 385
    (*pfun)(10) = 385
    pfun(10) = 385
    (*pfun)(10) = 385
    ```

通过编译生成汇编代码，观察两个函数调用的汇编代码部分基本相同。

**解释**：  

1. **函数指针赋值等效性**：
   - `pfun = myfunc` 和 `pfun = &myfunc` 在C语言中是等效的
   - 函数名本身就代表函数的地址，加不加取地址符号&没有区别

2. **函数调用等效性**：
   - `pfun(10)` 和 `(*pfun)(10)` 在C语言中也是等效的
   - 编译器生成的汇编代码中，这两种调用方式没有本质区别

3. **底层实现**：
   - 函数调用时，编译器只关心函数指针中存储的地址值
   - 无论通过哪种语法形式，最终都会转化为相同的机器指令：将参数压栈，然后跳转到函数地址执行
