# Class Lab 5 : Array

## 1. ⽬标

1. 观察函数局部存储的特性。
2. 掌握数组的存储和访问原理。

## 2. 课堂练习（需提交代码和⽂档，包括原理分析与数据观察）

### 2.1. 函数局部存储的管理

1. 编写⼀个递归函数：  
    函数原型： void test(int i);  
    函数内部声明⼀个局部数组，如 int a[10];  
    - 当 i > 10 时返回；  
    - 否则执⾏ a[i] = i; 并输出数组 a 全部元素的值；  
    - 然后递归调⽤ test(i + 1);  

观察：  

- 在递归调⽤的过程中，数组 a 在不同调⽤栈帧中的值的变化。  
- 计算第 i 次调⽤和第 i+1 次调⽤数组对应元素值的差异。  

要求：解释观察到的现象，并给出相关的内存管理原理。  

### 2.2. ⼆维数组的内存管理与系统限制

1. 在 main 函数中声明⼀个s⼆维数组，如： long a[n][n];  

- 从 1 开始为数组连续赋值⾄ n*n ，并输出 a[n-1][n-1] 。  

任务：  

- 测试程序能否正常执⾏，找到使程序执⾏失败的最⼩的 n 值。  
- 查阅资料并解释为什么 Linux 等操作系统对此类⼤数组声明有内存上的限制，为什么这种限制对⼤多数程序并⽆显著影响？  
- 查阅并尝试配置系统参数，使上述程序在更⼤规模（例如 n=1024 或更⼤）下能够正常执⾏，提交具体操作步骤。  

### 2.3. 数组的访问⽅式

1. 地址计算  
    声明数组： long a[10]; 和 long b[10][100];  
    计算并输出 (a + i) - a 和 (b + i) - b （取 i 为不同的整数值，如 1, 2, 5 等），解释输出结果含义。  
2. 数组越界访问⾏为  
    声明⼀个数组： short a[100] = {0x0f0f};  
    计算 short *x = a + 1000; 并打印地址值；然后尝试解引⽤ x ，即打印 *x 。  
    解释这种越界访问的程序⾏为及可能带来的后果。  
3. ⼆维数组元素映射  
    给定⼆维数组 int a[m][n] ，将数组元素与⾃然数（从 0 开始）建⽴映射关系，采⽤从最外层到最内层（顺时针螺旋）的⽅式逐个对应，例如：  

    ```txt
    0 1 2 3
    11 12 13 4
    10 15 14 5
    9 8 7 6
    ```

要求：  

- 编写函数，对任意给定的索引 (i, j) ，输出对应的⾃然数。
- 编写函数，对任意给定的⾃然数（⼩于 m*n ），输出其在⼆维数组中的位置 (i, j) 。

## 3. 第一题解答

[2_1.c](1/lab5_2_1.c)  
[analysis.md](1/lab5_2_1_analysis.md)  

## 4. 第二题解答

[2_2.c](2/lab5_2_2.c)  
[analysis.md](2/lab5_2_2_analysis.md)  

## 5. 第三题解答

[2_3_1.c](3/lab5_2_3_1.c) - 地址计算实验  
[2_3_2.c](3/lab5_2_3_2.c) - 数组越界访问实验  
[2_3_3.c](3/lab5_2_3_3.c) - 二维数组元素螺旋映射实验  
[analysis.md](3/lab5_2_3_analysis.md) - 实验分析  
