# 数组访问方式实验分析

## 1. 地址计算实验

### 1.1 实验结果

在64位系统上运行实验程序得到以下结果（地址值可能因运行环境不同而有所区别）：

```txt
数组地址计算实验
========================
sizeof(long) = 8 字节
sizeof(a[0]) = 8 字节
sizeof(b[0]) = 800 字节

一维数组a的地址计算:
a = 0x7ffe5e82dbc0
(a + 1) = 0x7ffe5e82dbc8
(a + 1) - a = 1
(a + 2) = 0x7ffe5e82dbd0
(a + 2) - a = 2
(a + 5) = 0x7ffe5e82dbe8
(a + 5) - a = 5
(a + 10) = 0x7ffe5e82dc10
(a + 10) - a = 10

二维数组b的地址计算:
b = 0x7ffe5e82dc20
(b + 1) = 0x7ffe5e82df30
(b + 1) - b = 1
(b + 2) = 0x7ffe5e82e240
(b + 2) - b = 2
(b + 5) = 0x7ffe5e82eb70
(b + 5) - b = 5
(b + 10) = 0x7ffe5e82f880
(b + 10) - b = 10
```

### 1.2 实验分析

1. **一维数组的地址计算**：  
   对于表达式 `(a + i) - a`，结果始终等于 `i`，这是因为：  
   - 指针加法中，`a + i` 实际上是 `a + i * sizeof(a[0])`
   - 当计算 `(a + i) - a` 时，系统会返回两个指针之间的元素个数
   - 因此 `(a + i) - a = i` 表示从 `a` 到 `a + i` 之间有 `i` 个元素

   实际内存地址的递增值为 `i * sizeof(long)`，在我们的系统上每个 `long` 占 8 字节

2. **二维数组的地址计算**：  
   对于表达式 `(b + i) - b`，结果也等于 `i`，但这里的指针运算涉及到整行的跳跃：  
   - 指针加法中，`b + i` 实际上是 `b + i * sizeof(b[0])`
   - `b[0]` 是整个行大小，在这里是 `100 * sizeof(long)`，即 800 字节
   - 当计算 `(b + i) - b` 时，系统返回两个指针之间的行数，即 `i`

   内存地址的实际递增值为 `i * 100 * sizeof(long)`，即 `i * 800` 字节

3. **指针运算的规则总结**：  
   - C/C++中的指针运算自动考虑了基础类型的大小
   - 表达式 `p + n` 中，实际的内存地址递增值为 `n * sizeof(*p)`
   - 表达式 `p - q`（两个相同类型的指针相减）返回的是元素个数，而非字节差距

## 2. 数组越界访问实验

### 2.1 实验结果

```txt
数组越界访问实验
========================
a = 0x7ffe5e82dbc0
a[0] = 0x0f0f
a[99] = 0x0000 (数组最后一个元素)

越界访问:
x = a + 1000 = 0x7ffe5e82fda0
越界地址与起始地址的差距: 2000 字节

尝试读取越界地址的值:
*x = 0x7ffe

尝试修改越界地址的值:
修改后 *x = 0xdead
```

### 2.2 实验分析

1. **越界访问的行为**：
   - 当我们计算 `a + 1000` 时，实际上是超出了数组的边界，指向了数组之外的内存
   - 从上面可以看出，地址增加了 2000 字节（因为每个 short 是 2 字节，所以 1000 个元素是 2000 字节）

2. **越界读取**：
   - 我们成功读取了越界地址的数据（`*x = 0x7ffe`）
   - C 语言不会检查数组边界，允许程序访问任何计算出的地址
   - 输出的值是内存中原本存在的数据，可能是其他变量、函数参数或栈帧信息

3. **越界写入**：
   - 我们成功修改了越界地址的值为 `0xdead`
   - 这可能覆盖了其他数据，如其他变量、返回地址等
   - 在某些情况下，这可能导致程序崩溃、数据损坏或安全漏洞

4. **潜在风险**：
   - **数据损坏**：可能覆盖其他变量的值
   - **程序崩溃**：如果修改了程序控制相关的内存区域
   - **安全漏洞**：缓冲区溢出是许多安全攻击的基础
   - **未定义行为**：标准不保证越界访问的任何特定行为，在不同系统上可能有不同结果

5. **为什么程序没有立即崩溃**：
   - 现代操作系统有内存保护机制，但它们只能在进程尝试访问不属于其地址空间的内存时触发
   - 如果越界访问仍在进程的地址空间内，操作系统不会干预
   - 是否会导致崩溃取决于越界访问是否触碰到关键的程序数据或受保护的内存区域

## 3. 二维数组元素映射实验

### 3.1 实验结果

```txt
二维数组元素螺旋映射实验
===========================

螺旋矩阵 (4 x 4):
 0  1  2  3 
11 12 13  4 
10 15 14  5 
 9  8  7  6 

测试从索引到自然数的映射:
(i=0,j=0) -> 0
(i=1,j=1) -> 12
(i=2,j=2) -> 14
(i=3,j=0) -> 9

测试从自然数到索引的映射:
0 -> (i=0,j=0)
5 -> (i=1,j=3)
10 -> (i=2,j=0)
15 -> (i=2,j=2)

更大规模的矩阵测试:
螺旋矩阵 (5 x 6):
 0  1  2  3  4  5 
15 16 17 18 19  6 
14 23 24 25 20  7 
13 22 29 26 21  8 
12 11 10  9  8  7 
```

### 3.2 实验分析

1. **螺旋映射原理**：
   - 螺旋映射是一种将二维平面上的点与自然数之间建立对应关系的特殊映射方式
   - 按照从外到内、顺时针旋转的顺序，将二维数组元素与连续自然数一一对应

2. **位置到自然数的映射算法**：
   - 首先确定点(i,j)所在的"层"（从外向内）
   - 计算外层所有元素的总数
   - 确定点在当前层的位置（上、右、下、左四条边的哪一条）
   - 计算在当前层的偏移量

3. **自然数到位置的映射算法**：
   - 先确定自然数对应的"层"
   - 在该层中继续寻找确切位置
   - 这个过程是反向的，通过逐层计算元素数量来确定

4. **算法实现的关键点**：
   - 确定点(i,j)所在的层：`layer = min(i, j, m-1-i, n-1-j)`
   - 当前层各边的元素个数：上边n-2*layer个，右边m-2*layer-2个，以此类推
   - 在循环结构中，点的位置可以按照上、右、下、左四个方向顺序判断

5. **算法复杂度**：
   - 位置到自然数的映射：时间复杂度O(min(m,n))，主要消耗在计算外层元素个数
   - 自然数到位置的映射：时间复杂度O(min(m,n))，同样消耗在确定层数
   - 空间复杂度都是O(1)，只需常数级别的变量

6. **应用场景**：
   - 图形处理中的特殊扫描方式
   - 二维数据的压缩和序列化存储
   - 某些算法问题中的矩阵访问模式

这种螺旋映射方式提供了一种有趣的二维数据组织和访问方式，在图像处理、矩阵遍历等场景中有实际应用。实验结果显示，我们的算法能够正确实现双向映射，无论是从位置到自然数，还是从自然数到位置。
