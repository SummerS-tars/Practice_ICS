# 函数局部存储管理实验分析

## 实验观察

运行程序后，可以观察到以下现象：

1. 每次递归调用时，数组`a`的值都会不同
2. 在每个函数调用中，只有对应索引`i`的位置被设置为`i`，其他位置保持为0
3. 前一次调用的数组值不会影响后续调用中的数组值
4. 即使是同一个数组名`a`，在不同的递归层级中实际上指向不同的内存位置

示例输出(部分)：  

```txt
函数调用 test(0) 的数组值: 0 0 0 0 0 0 0 0 0 0 
函数调用 test(1) 的数组值: 0 1 0 0 0 0 0 0 0 0 
函数调用 test(2) 的数组值: 0 0 2 0 0 0 0 0 0 0 
...
函数调用 test(9) 的数组值: 0 0 0 0 0 0 0 0 0 9 
函数调用 test(10) 的数组值: 0 0 0 0 0 0 0 0 0 0 
```

## 内存管理原理解释

### 1. 栈帧的创建与销毁

每当函数`test`被调用时，系统会为其创建一个新的**栈帧**（Stack Frame）。栈帧包含了函数的参数、返回地址、局部变量等。在这个实验中，数组`a`是函数`test`的局部变量，它属于当前栈帧。

### 2. 函数的局部存储特性

当函数执行时，它的局部变量（包括局部数组）存储在当前栈帧中。每次递归调用创建了一个全新的栈帧，因此每次调用都有自己独立的数组`a`副本，互不影响。

### 3. 栈内存的分配与回收

- 当函数被调用时，栈指针向下移动（在大多数系统中），为新的栈帧分配空间
- 当函数返回时，栈指针向上移动，释放栈帧占用的空间
- 被释放的栈帧内存不会被清零，但不再被当前执行上下文访问

### 4. 数组元素值的差异

对于第i次调用和第i+1次调用的数组对应元素值的差异：

- 在第i次调用中，a[i]=i，其他元素为0
- 在第i+1次调用中，a[i+1]=i+1，其他元素为0
- 因此，这两次调用中，只有两个元素不同：位置i和位置i+1

### 5. 内存布局

如果我们在内存中可视化这个递归过程，大致会如下所示：

```txt
高地址
+----------------+
| main()的栈帧    |
+----------------+
| test(0)的栈帧   | ← 包含test(0)的局部数组a
+----------------+
| test(1)的栈帧   | ← 包含test(1)的局部数组a
+----------------+
| test(2)的栈帧   | ← 包含test(2)的局部数组a
+----------------+
| ...            |
+----------------+
| test(10)的栈帧  | ← 包含test(10)的局部数组a
+----------------+
低地址
```

这种设计使得递归函数能够安全地工作，因为每次调用都有自己独立的变量空间，不会干扰其他函数调用。但同时，这也会消耗较多的栈空间，如果递归层次太深，可能导致栈溢出（Stack Overflow）。
